/**
 * Asset Scanner Utility
 * 
 * This script scans the public directory for media files and generates
 * an updated asset list for preloading.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get current file directory (equivalent to __dirname in CommonJS)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const PUBLIC_DIR = path.join(__dirname, '../public');
const OUTPUT_FILE = path.join(__dirname, '../src/utils/assetList.js');

// File extensions to look for
const IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.webp'];
const VIDEO_EXTENSIONS = ['.mp4', '.webm'];
const GIF_EXTENSIONS = ['.gif'];

// Assets to exclude (optional)
const EXCLUDE_PATTERNS = [
  // Add patterns to exclude if needed
  // e.g., 'temp/', 'draft-'
];

// Function to check if a file should be excluded
const shouldExclude = (filePath) => {
  return EXCLUDE_PATTERNS.some(pattern => filePath.includes(pattern));
};

// Function to get all media files recursively
const getAllMediaFiles = (dir) => {
  const images = [];
  const videos = [];
  const gifs = [];

  // Helper function to scan directories recursively
  const scanDir = (currentDir, relativePath = '') => {
    const files = fs.readdirSync(currentDir);
    
    files.forEach(file => {
      const filePath = path.join(currentDir, file);
      const stats = fs.statSync(filePath);
      
      // Create relative path for asset
      const assetPath = path.join(relativePath, file).replace(/\\/g, '/');
      
      if (stats.isDirectory()) {
        // Recursively scan subdirectories
        scanDir(filePath, assetPath);
      } else if (stats.isFile() && !shouldExclude(assetPath)) {
        const ext = path.extname(file).toLowerCase();
        
        // Categorize files by extension
        if (IMAGE_EXTENSIONS.includes(ext)) {
          images.push('/' + assetPath);
        } else if (VIDEO_EXTENSIONS.includes(ext)) {
          videos.push('/' + assetPath);
        } else if (GIF_EXTENSIONS.includes(ext)) {
          gifs.push('/' + assetPath);
        }
      }
    });
  };
  
  // Start scanning from the public directory
  scanDir(dir);
  
  return { images, videos, gifs };
};

// Function to group assets by section
const groupAssetsBySection = (assets) => {
  const groupedAssets = {
    images: {},
    videos: {},
    gifs: {}
  };
  
  // Helper function to determine the section based on path
  const getSection = (filePath) => {
    if (filePath.includes('/images/')) {
      // Extract section from path, e.g., /images/digitaldaydream/ -> digitaldaydream
      const match = filePath.match(/\/images\/([^\/]+)\//);
      if (match && match[1]) {
        return match[1];
      }
    }
    
    // For root level assets
    return 'global';
  };
  
  // Group each asset type by section
  ['images', 'videos', 'gifs'].forEach(type => {
    assets[type].forEach(filePath => {
      const section = getSection(filePath);
      
      if (!groupedAssets[type][section]) {
        groupedAssets[type][section] = [];
      }
      
      groupedAssets[type][section].push(filePath);
    });
  });
  
  return groupedAssets;
};

// Function to generate the asset list file
const generateAssetListFile = (groupedAssets) => {
  // Start building the file content
  let fileContent = `/**
 * Asset List for Preloading
 * 
 * This file is auto-generated by the updateAssetList.js script.
 * Do not edit this file directly.
 */

// List of assets to preload
const assetList = {
  images: [
`;

  // Add images by section
  Object.entries(groupedAssets.images).forEach(([section, paths]) => {
    fileContent += `    // ${section.charAt(0).toUpperCase() + section.slice(1)} assets\n`;
    paths.forEach(path => {
      fileContent += `    '${path}',\n`;
    });
    fileContent += '\n';
  });

  // Remove trailing newline and add videos section
  fileContent = fileContent.trim() + `
  ],
  videos: [
`;

  // Add videos by section
  Object.entries(groupedAssets.videos).forEach(([section, paths]) => {
    fileContent += `    // ${section.charAt(0).toUpperCase() + section.slice(1)} videos\n`;
    paths.forEach(path => {
      fileContent += `    '${path}',\n`;
    });
    fileContent += '\n';
  });

  // Remove trailing newline and add gifs section
  fileContent = fileContent.trim() + `
  ],
  gifs: [
`;

  // Add gifs by section
  Object.entries(groupedAssets.gifs).forEach(([section, paths]) => {
    fileContent += `    // ${section.charAt(0).toUpperCase() + section.slice(1)} GIFs\n`;
    paths.forEach(path => {
      fileContent += `    '${path}',\n`;
    });
    fileContent += '\n';
  });

  // Finish the file
  fileContent = fileContent.trim() + `
  ]
};

export default assetList;
`;

  // Write the file
  fs.writeFileSync(OUTPUT_FILE, fileContent);
  
  console.log(`Asset list updated with ${Object.values(groupedAssets.images).flat().length} images, ${Object.values(groupedAssets.videos).flat().length} videos, and ${Object.values(groupedAssets.gifs).flat().length} GIFs.`);
};

// Main execution
try {
  console.log('Scanning for media assets...');
  const assets = getAllMediaFiles(PUBLIC_DIR);
  const groupedAssets = groupAssetsBySection(assets);
  generateAssetListFile(groupedAssets);
  console.log('Asset list updated successfully!');
} catch (error) {
  console.error('Error updating asset list:', error);
  process.exit(1);
}
